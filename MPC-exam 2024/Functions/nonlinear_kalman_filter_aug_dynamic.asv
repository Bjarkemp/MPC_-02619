function [x_hat, x_phat] = nonlinear_kalman_filter_aug_dynamic(t, xdev, udev, ddev,  x0, u, d, At, rho, R, Q_aug, Ad_aug, Gw_aug, C_aug, p)
%--------------------------------------------------------------------------
x_hat = [];
Lr = chol(R,'lower');                % Cholesky-dekomposition. It just gives me the standard deviation instead of variance.
v = Lr*(randn(size(xdev)));          % Measurement noise. Follows normal distribution with mean=0 and has st.dev of Lr
xhat_k_k1 = xdev(:,1)];  % Start med det initiale tilstandsskøn
P_k_k1 = 100 * eye(size(Ad_aug, 1)); % Høj initial kovarians for at tage højde for usikkerhed


for k = 1:length(t)-1
    % Filtering
    % Innovationskovarians
    Re_k = C_aug * P_k_k1 * C_aug' + R;
    % Kalman-gain
    K = P_k_k1 * C_aug' * inv(Re_k);
    yk = mass_to_height(xdev(:,k),At,rho) + v(:,k);
    yhat_k_k1 = mass_to_height(xhat_k_k1(1:4),At,rho) + v(:,k);  % Prediktion af måling
    ek = yk - yhat_k_k1;  % Innovationssekvens
    % Update step
    xhat_k_k = xhat_k_k1 + K * ek; 
    % One-step prediction
     
    x_k_k = xhat_k_k(1:4)+x0;
    [T, X, D, U, x_sample2] = discrete_fourtankProcess(x_k_k, [t(k) t(k+1)], u(:,k), d(:,k), p);
    x_phat(:,k) = [x_sample2(end,:)' - x0];

    P_k_k = P_k_k1 - K*Re_k*K';
    x_hat = [x_hat xhat_k_k];  % Gem skønnet tilstand
    % Prediktion af fejlkovarians
    P_k_k1 = Ad_aug * P_k_k * Ad_aug' + Q_aug;%+ Gw_aug*Q_aug*Gw_aug';
    xhat_k_k1 = x_phat(:,k);  % Forbered næste iteration
end

k = length(t);

Re_k = C_aug * P_k_k1 * C_aug' + R;
    % Kalman-gain
    K = P_k_k1 * C_aug' * inv(Re_k);
    yk = mass_to_height(xdev(:,k),At,rho) + v(:,k);
    % yhat_k_k1 = C_aug*xhat_k_k1 + v(:,k);  % Prediktion af måling
    yhat_k_k1 = mass_to_height(xhat_k_k1(1:4),At,rho) + v(:,k);  % Prediktion af måling
    ek = yk - yhat_k_k1;  % Innovationssekvens
    % Update step
    xhat_k_k = xhat_k_k1 + K * ek; 

    x_hat = [x_hat xhat_k_k];
%-------------------------------------------------------------------------
