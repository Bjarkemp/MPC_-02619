\subsection{Design of Input Constrained and Soft Output Constrained MPC - Point 1, 2 \& 3}
\label{sec:in_out_con_MPC}
In the previous paragraph the MPC was implemented with hard constraints on the input, meaning that the solution will never determine a value which was outside these constraints. When adding constraints on the output, they are determined as soft constraints in order to make the solution more robust. The solution is once again build on the discrete time linear model, however the objective function will be changed to the following:
\begin{equation}
     \text{min}\quad \phi=\phi_z+\phi_{\Delta\,u}+\phi_u+\phi_s+\phi_t
\end{equation}
Each of the elements will be described below. Since the qp solver has a specific interface as seen in \cref{sec:QPsolver} \cref{eq:QP_solver} the general expression for each of the elements of $\phi$ will be rewritten, in order to setup a complete expression for $H$, $A$, $l$, $u$, $b_u$ and $b_l$.
\subsubsection*{Objective term relating to the output ($\Phi_z$)}
$\phi_z$ is determined as:
\begin{equation}
    \phi_z=\frac{1}{2}\, \overset{N}{\underset{k=0}{\sum}}\norm{W_z(z_k-r_k)}_2^2
\end{equation}
Where $Q_z=W_z^TW_z$, hence $W_z$ is the tuning parameter. $r(k)$ is the reference signal and $z(k)$ is defined as 
\begin{equation}
    z(k)=\underbrace{\phi\,x_k+\phi_w\,w_k}_{b_k}+\Gamma\,U
\end{equation}
Where $\phi$ and $\Gamma$ was determined in \cref{sec:uncon_MPC}, and the remaining elements is determined as
\begin{equation*}
    Z_k=\begin{bmatrix}
        z_{k+1}\\
        z_{k+2}\\
        z_{k+3}\\
        \vdots\\
        z_{k+N}
    \end{bmatrix} \quad
    U_k=\begin{bmatrix}
        u_{k+1}\\
        u_{k+2}\\
        u_{k+3}\\
        \vdots\\
        u_{k+N}
    \end{bmatrix} \quad
    \phi_w=\begin{bmatrix}
        CE\\
        CAE\\
        CA^2E\\
        \vdots\\
        CA^{N-1}E
    \end{bmatrix} \quad
\end{equation*}
The objective function is now rewritten to take the form used in the qp solver.
\begin{equation}
    \phi_z=\frac{1}{2}U_k^T\underbrace{((\Bar{W}_z\,\Gamma)^T\Bar{W}_z\,\Gamma)}_{H_z}U_k+{\underbrace{(-(\Bar{W}_z\,\Gamma)^T\Bar{W}_z\,c_k)}_{g_z}}^TU_k+\underbrace{\frac{1}{2}(c_k\Bar{W}_z)^T\Bar{W}_z\,c_k}_{\rho_z}
\end{equation}
Where
\begin{equation}
    \Bar{W}_z=I_N\otimes\,W_z \qquad c_k=R_k-b_k
\end{equation}
\subsubsection*{Objective term relating to the input variation ($\Phi_{\Delta\,u}$)}
$\phi_{\Delta u}$ is determined as.
\begin{equation}
    \phi_{\Delta u}=\frac{1}{2}\,\overset{N-1}{\underset{k=0}{\sum}}\norm{W_{\Delta u}(\Delta u_k )}_2^2
\end{equation}
Where $S=W^T_{\Delta u}W_{\Delta u}$, hence $W_{\Delta u}$ is the tuning parameter. The objective function is now rewritten to take the form used in the qp solver.
\begin{equation}
    \phi_{\Delta\,u}=\frac{1}{2}U_k^T\underbrace{\left((\Bar{W}_{\Delta u}\,\Lambda)^T\Bar{W}_{\Delta u}\,\Lambda\right)}_{H_{\Delta\,u}}U_k+{\underbrace{\left(-(\Bar{W}_{\Delta u}\,\Lambda)^T\Bar{W}_{\Delta u}\,I_0\,u_{-1}\right)}_{g_\Delta u}}^TU_k+\underbrace{\frac{1}{2}\left(\Bar{W}_{\Delta u}\,I_0\,u_{-1}\right)^T\Bar{W}_{\Delta u}\,I_0\,u_{-1}}_{\rho_{\Delta u}}
\end{equation}
Where $\Lambda$ was determined in \cref{sec:in_con_MPC} and $\Bar{W}_{\Delta u}$ is given by
\begin{equation}
    \Bar{W}_{\Delta u}=I_N\otimes\,W_{\Delta u}
\end{equation}
\subsubsection*{Objective term relating to the input distance from a predetermined value ($\Phi_u$)}
$\phi_u$ allows the controller to penalize the input on basis of a predetermined value $\Bar{u}_k$
\begin{equation}
    \begin{matrix}
        \phi_u=\frac{1}{2}\, \overset{N-1}{\underset{k=0}{\sum}}\norm{\Bar{W_u}(u_k-\Bar{u}_k)}_2^2\\
        \phi_u=\frac{1}{2}U_k^T\underbrace{\left(\Bar{W}_u^T\Bar{W}_u\right)}_{H_u}U_k+{\underbrace{\left(-\Bar{W}_u^T\Bar{W}_u\Bar{U}_k\right)}_{g_u}}^TU_k+\underbrace{\frac{1}{2}\Bar{U}_k\Bar{W}_u^T\Bar{W}_u\Bar{U}_k}_{\rho_u}
    \end{matrix}
\end{equation}
where
\begin{equation}
    \Bar{W}_u=I_N\otimes\,W_u
\end{equation}
and $W_u$ is a tuning parameter.
\subsubsection*{Objective term relating to the lower soft constraints ($\Phi_s$)}
The idea of implementing soft constraints on the output, is to allow the algorithm to violate these constraints, at high costs, in order to ensure the controller can find a optimal solution. This is done by using slack varaibles denoted $S_k$. $\phi_s$ is given by
\begin{equation}
       \phi_s=\frac{1}{2}\, \overset{N-1}{\underset{k=0}{\sum}}\norm{W_{s,2}(s_k)}_2^2+\frac{1}{2}\, \overset{N-1}{\underset{k=0}{\sum}}\norm{W_{s,1}(s_k)}_1 \qquad , \qquad
       \begin{matrix}
       Z_k\geq R_{min,k}-S_k \\ S_k\geq 0
       \end{matrix}
\end{equation}
Where $W_{s,1}$ and $W_{s,2}$ is tuning parameters. $R_{min,k}$ is the constraint the output should be larger than at all times, unless it is not possible. In the case where the output becomes smaller than $R_{min}$, $S_k$ (see \cref{eq:soft_Sk}) becomes non zero. As mentioned, it is not desirable to violate the soft constraints, and therefore is the tuning $W_{s,1}$ and $W_{s,2}$ are often chosen to be relative high. 
\begin{equation}
    S_k=\begin{bmatrix} s_{k+1}\\ s_{k+2}\\ \vdots\\ s_{k+N} \end{bmatrix}
    \label{eq:soft_Sk}
\end{equation}
The objective term is rewritten into
\begin{equation}
     \phi_s=\frac{1}{2}S_k^T\underbrace{\left(\Bar{W}_{s,2}^T\Bar{W}_{s,2}\right)}_{H_s}S_k+{\underbrace{\left(\Bar{W}_{s,1} e\right)}_{g_s}}^TS_k
\end{equation}
Where 
\begin{equation}
    \begin{gathered}
        \Bar{W}_{s,1}=I_N\otimes\,W_{s,1}\\
        \Bar{W}_{s,2}=I_N\otimes\,W_{s,2}\\
        e=\begin{bmatrix}1 & 1 & \dots & 1\end{bmatrix}^T
    \end{gathered}
\end{equation}
\subsubsection*{Objective term relating to the upper soft constraints ($\Phi_t$)}
The idea of implementing a soft upper constraint is similar to the soft lower constraint.
$\phi_t$ is given by
\begin{equation}
       \phi_t=\frac{1}{2}\, \overset{N-1}{\underset{k=0}{\sum}}\norm{W_{t,2}(t(k))}_2^2+\frac{1}{2}\, \overset{N-1}{\underset{k=0}{\sum}}\norm{W_{t,1}(t(k))}_1 \qquad , \qquad
       \begin{matrix}
       Z_k\leq R_{max,k}+T_k \\ T_k\geq 0
       \end{matrix}
\end{equation}
Where $W_{t,1}$ and $W_{t,2}$ is tuning parameters. Similar to the lower bound, thse should be chosen to be high. $R_{max,k}$ is the upper soft constraint and $T_k$ is determined as.
\begin{equation}
    T_k=\begin{bmatrix} t_{k+1}\\ t_{k+2}\\ \vdots\\ t_{k+N} \end{bmatrix}
    \label{eq:soft_Tk}
\end{equation}
The objective term is rewritten into
\begin{equation}
     \phi_t=\frac{1}{2}T_k^T\underbrace{\left(\Bar{W}_{t,2}^T\Bar{W}_{t,2}\right)}_{H_t}T_k+{\underbrace{\left(\Bar{W}_{t,1} e\right)}_{g_t}}^TT_k
\end{equation}
Where 
\begin{equation}
    \begin{gathered}
        \Bar{W}_{t,1}=I_N\otimes\,W_{t,1}\\
        \Bar{W}_{t,2}=I_N\otimes\,W_{t,2}\\
    \end{gathered}
\end{equation}
\subsubsection*{Combination of objective function}
Since all the objective functions has been determined individually, it is now combined. It is of interest to minimize, $U_k$, $S_k$ and $T_k$, which yields
\begin{equation}
    \underset{U_k,S_k,T_k}{min}\qquad\frac{1}{2}\begin{bmatrix}
        U_k\\ S_k\\ T_k
    \end{bmatrix}^T
    \underbrace{\begin{bmatrix}
        H & 0 & 0\\
        0 & H_s & 0\\
        0 & 0 & H_t
    \end{bmatrix}}_H
    \begin{bmatrix}
        U_k\\ S_k\\ T_k
    \end{bmatrix}+
    {\underbrace{\begin{bmatrix}
        g\\ g_s\\ g_t
    \end{bmatrix}}_g}^T
    \begin{bmatrix}
        U_k\\ S_k\\ T_k
    \end{bmatrix} + \rho
\end{equation}
The remaining inputs to the qp solver is given by.
\begin{equation}
    \begin{gathered}
        \underbrace{\begin{bmatrix}
            U_{min,k} \\ 0 \\ 0
        \end{bmatrix}}_l \leq
        \begin{bmatrix}
            U_k \\ S_k \\ T_k
        \end{bmatrix} \leq
        \underbrace{\begin{bmatrix}
            U_{max,k} \\ \infty \\ \infty
        \end{bmatrix}}_u \\
        \underbrace{\begin{bmatrix}
            \Delta U_{min}+I_0 u_{-1}\\ R_{min,k}-b_k \\ -\infty
        \end{bmatrix}}_{b_l} \leq
       \underbrace{\begin{bmatrix}
            \Lambda & 0 & 0\\
            \Gamma & I & 0\\
            \Gamma & 0 & -I\\
        \end{bmatrix}}_A
        \begin{bmatrix}
            U_k\\ S_k\\ T_k
        \end{bmatrix} \leq
        \underbrace{\begin{bmatrix}
            \Delta U_{max}+I_0 u_{-1}\\ \infty \\ R_{max,k}-b_k
        \end{bmatrix}}_{b_u}
    \end{gathered}
\end{equation}
The implementation in \textit{MatLab} is carried out through three functions. Prior to the simulation, the MPC design i carried out (see \cref{app:InOut_Design}) where, the matrices for all $H$, $g$ and $M$ is determined. In order to do this, the function calls the previous function (see \cref{app:MPC_Constants}) where $\phi$ and $\Gamma$ is determined. Finally, the qpsolver is called. (see \cref{app:InOut_MPC})